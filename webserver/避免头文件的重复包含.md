
## 为什么

当头文件被包含两次或多次时，会导致重复定义错误（multiple definition error）和重复声明错误（multiple declaration error）。这是因为头文件中通常包含了变量定义和函数声明，如果多次包含同一个头文件，其中的定义和声明会被重复插入到每个包含它的源文件中，从而导致重复定义和声明。

具体来说：

1. 重复定义错误：如果头文件中包含了全局变量或静态变量的定义，那么在每个源文件中都会看到这个变量的定义。在编译链接时，编译器会发现多个相同名字的变量定义，从而产生重复定义错误。
    
2. 重复声明错误：如果头文件中包含了函数的声明，那么在每个源文件中都会看到这个函数的声明。在链接时，编译器会发现多个相同名字的函数声明，从而产生重复声明错误。
    

这些错误会导致编译失败，从而阻止生成可执行程序。解决这些问题的一种常见方法就是使用条件编译技巧，比如在头文件中使用 `#ifndef` 和 `#define` 宏定义来确保头文件只被编译一次，避免了重复的定义和声明。

因此，编写头文件时，务必采取措施避免头文件的重复包含，以确保程序编译和链接的正确性。条件编译是一种简单有效的方法，可以在多个源文件中包含同一个头文件，但确保只有一个头文件实际被编译和使用。


### 怎么办

#### 1.使用条件编译

[[day02-不要放过任何一个错误]]如这篇中的代码一样，在util.h头文件中：
```c++
# ifndef UTIL_H
# define UTIL_H

void errif(bool,const char *);

# endif
```
[C++ 包含头文件 和 宏的使用 和 条件编译 - 矮油~ - 博客园](https://www.cnblogs.com/rednodel/p/5000650.html)

#### 2.使用`#pragma once`
[[day04-来看看我们的第一个类]]

`#pragma once` 是一种预处理指令，用于确保头文件只被编译一次，防止重复包含的问题。它的作用与传统的条件编译（例如使用 `#ifndef` 和 `#define` 宏）相同，但更加简洁和直观。

具体来说，当一个头文件使用 `#pragma once` 进行标记时，编译器会在编译时检查这个头文件是否已经被包含过。如果已经包含过，编译器将忽略对该头文件的后续包含请求，避免了头文件的重复定义和声明。

使用 `#pragma once` 的优点包括：

1. 简洁性：相比传统的条件编译方式，`#pragma once` 更简洁，只需要一行代码就可以实现防止头文件重复包含的功能。

2. 可读性：`#pragma once` 语义更直观，一目了然地表明了其作用，不需要像条件编译那样引入宏定义和条件块。

3. 高效性：`#pragma once` 在大多数编译器上都被优化，因此比传统条件编译方式稍微快一些。

需要注意的是，`#pragma once` 是标准C/C++的一部分，但并不是所有编译器都支持它。大多数主流的编译器都支持 `#pragma once`，包括GCC、Clang、MSVC等。然而，为了确保代码的可移植性，有些程序员仍然倾向于使用传统的条件编译方式。
