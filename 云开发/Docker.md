# Docker


## 1 Introduction

Docker is a software solution that can be used to deploy and run applications in an isolated environment, called a container. The main difference with respect to a virtual machine is that all the containers running on the same host share the same operating system kernel.

The goals of this lab are to:

- Discover the basics of Docker.
- Learn how to run a container.
- Find out how to manage containers
- Discover how to build a Docker image and push it to a registry.

## 2 Installing Docker

Docker is already installed on your local Virtual Machine. You only have to configure Docker to use a cache when downloading images from a public repository.

Add the following contents to `/etc/docker/daemon.json` and restart Docker.

```
{
  "registry-mirrors": ["https://registry.cloud.rennes.enst-bretagne.fr:5000"]
}  
```

## 3 Running Mongo in a Container

### 3.1 Docker Run

During the previous lab, you installed a Mongo server on your OpenStack VM. Now you will continue with Mongo and run a Mongo server in a Docker container on your local VM.

Type the following command in a Terminal.

```
> docker run -d mongo
```

If everything goes well, you should see the ID of the container you just launched displayed on your Terminal. You can also use `docker ps` to display the list of containers running on your local VM (also called Docker Host)

Type the following command in a Terminal.

```
> docker ps
```

You should get an output that looks like the one shown below.

```
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS       NAMES
5ac116d2d1d5   mongo     "docker-entrypoint.s…"   8 minutes ago   Up 8 minutes   27017/tcp   youthful_colden
```

As you can see the ID of your container is truncated so that it does not occupy all the space in width of your Terminal. If you want to find the ID in its non-truncated version you can add the `--no-trunc-` option to the `docker ps` command. You can also see that a name has been assigned to your container. In the example above, it is `youthful_colden`. Of course, you can choose this name explicitly by using the `--name` option with the `docker run` command as shown below.

```
> docker run -d --name mymongo mongo
```

As you probably guessed, `mongo` is not the name of the container but the name of the image used to start the container. Just as to start a VM in OpenStack you have to provide an operating system image (`ubuntu20`), here with containers you have to provide a Docker image. A Docker image is a collection of files containing everything needed to run a container: application code, libraries and dependencies.

Like any service running in a container, the Mongo container you started has its own process space, file space, network stack, etc. Each container is thus isolated from the other containers running on the same docker host but they all share the same operating system kernel.

Before continuing the discovery of the docker containers, a word about the `-d` option used in `docker run -d mongo`. It means `detach` and is simply used so that your Terminal is not used to echo the output of the command executed by your Docker container.

### 3.2 Docker Inspect and Docker Logs

Since you have a Mongo server running in a Docker container, it is now time to try to interact with it. It is outside the scope of this UE to study Docker networking but you should, at a minimum, know that when a container is started, by default, it is connected to a default bridge network, it has its own IP and you can reach this IP address from your VM (Docker Host).

Use the `docker inspect` command to get the IP of your container.

```
> docker inspect mymongo
```

If you find that there is too much information, you can either use the `--format` option to the docker command or pipe the output to the `jq` command to extract only what you want.

```
> docker inspect --format='{{.NetworkSettings.IPAddress}}' mymongo
> docker inspect mymongo | jq .[0].NetworkSettings.IPAddress
```

For more information on how to use this option or the `jq` command, refer to https://stedolan.github.io/jq/manual/ for `jq` and https://pkg.go.dev/text/template for GO template used by the `--format` option.

Now that you know the IP of your container hosting Mongo, use the mongo shell on your local VM to add a document to a database.

Since you have detached the container from your Terminal, you do not see the output of any information or error messages that may be generated by the Mongo server. The `docker logs` command.

```
> docker logs mymongo
```

### 3.3 Where does the Mongo Docker Image Come From ?

When you run a VM on OpenStack, you use an image, like for example `ubuntu20`, that has been previously installed by the administrator of the OpenStack platform. But, when you run a Mongo container on your docker host, where does the `mongo` image come from? It usually comes from a public registry and in particular from Docker Hub, a public registry of docker images, organized as a collection of repositories, managed by **Docker Inc.**. The first time you use a Docker image to run a container on a Docker host triggers a pull of the image. You can also explicitly do a pull of an image. For example, to pull the `mysql` docker image, use the following command.

```
> docker pull mysql
```

The previous command retrieves an image from the Docker Hub public registry and is equivalent to the following command:

```
> docker pull docker.io/library/mysql
```

You can read the documentation of the `mysql` image at the following address: https://hub.docker.com/_/mysql. In general, you are strongly encouraged to read the documentation of the public Docker images you use. You will discover there the possibility to fine-tune the behavior of the image by using environment variables or initialization files.

There are other public registries like the one managed by **Red Hat**. To pull an image from this registry (`quay.io`), you have to give explicitly the name of the registry:

```
> docker pull quay.io/coreos/etcd
```

Soon, you will discover how to use your own private registry to upload your own images.

## 4 Some Additional Explanations abour Running a Container

Now that you know how to run a docker container, it's time to go back to this `docker run` command. It is actually a shortcut for two different actions:

- create a container with `docker create`
- starting a container with `docker start`

Therefore, the `docker run -d --name mymongo mongo` command you used earlier can be replaced by:

1. `docker create --name mymongo mongo`
2. `docker start mymongo` (no `-d` option here because, by default, it is detached from the terminal)

When you use `docker ps`, you only see the running containers. If you want to see the created but stopped (or not yet running) containers you have to use the `-a` option:

```
> docker ps
  CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
> docker ps -a
  CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                     PORTS     NAMES
  b3f41ee3a6cd   mongo     "docker-entrypoint.s…"   12 seconds ago   Exited (0) 4 seconds ago             mymongo
```

If you start a container and stop it either with a CTRL-C (no `-d` option to `docker run`) or with `docker stop`, you cannot restart it with the same name. You get a message like the one below:

```
docker: Error response from daemon: Conflict. The container name "/mymongo" is already in use by container
```

You have to remove the container (`docker rm`) before being able to run a new container with the same name you used before. If you want either a CTRL-C or a `docker stop` to remove the container as well, then you have to run it with the `--rm` option.

```
> docker run --rm -d --name mymongo mongo
  deb1b0f9b014161180af32fa24c3b22ea645386e23f2a45725cf0f5a5f5db733
> docker ps
  CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS       NAMES
  deb1b0f9b014   mongo     "docker-entrypoint.s…"   7 seconds ago   Up 6 seconds   27017/tcp   mymongo
> docker stop mymongo 
  mymongo
> docker ps -a
  CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

It seems a bit complicated but it is quite logical. Note that it is rare to use the `docker create` and `docker start` commands separately and that we generally prefer to use `docker run`.

## 5 Running HTTP Server in a Container

In the previous example using a `mongo` image, you implicitly used a command when you ran your container with `docker run`. You can easily check this with `docker ps --no-trunc` (observe the `COMMAND` column). The default command is defined in the image and you don't have to specify it when you run the container. For other images, it makes sense to specify a command at `docker run`time. This is for example the case of the `python:3` image that you can use to start a particular python module.

Type the following command in a Terminal to run an HTPP server inside a container.

```
> docker run python:3 python3 -m http.server 8080
```

What does the above command do? It runs a docker container (`docker run`). The image of the container is `python:3` and the command to be executed after the container has started is `python3 -m http.server 8080`.

Launch a new Terminal and ask docker for the details of the container running the HTTP server. Then, by using the `curl` command, try to reach the HTTP server. Please, read the first lines of the `curl` manual page to know how to use this tool or read this document:https://curl.haxx.se/docs/httpscripting.html. You may also use a web-browser (Firefox) in the virtual machine to access the HTTP server running inside the container. Remember that you have started the server on port 8080!

If everything is OK, you should see the list of directories under `/` **in your container**, that is `bin`, `boot`, `dev`, `etc`, `home`, `lib`, etc. Right now you have a web server running but it does not serve anything very interesting/useful. Your first task is therefore to add three files to the running container so that they will be served.

On your local VM, create a directory named `mywebserver` and from this directory, download three files fromhttp://www.cloud.rennes.enst-bretagne.fr/files/docker-lab

```
> mkdir mywebserver; cd mywebserver
> wget http://www.cloud.rennes.enst-bretagne.fr/files/docker-lab/file1.html
> wget http://www.cloud.rennes.enst-bretagne.fr/files/docker-lab/file2.html
> wget http://www.cloud.rennes.enst-bretagne.fr/files/docker-lab/file3.html
```

Your `mywebserver` directory should now contain the three following files: `file1.html`, `file2.html` and `file3.html`.

Find a way to 1) remove the `tmp` directory (inside the **container**) 2) add the three downloaded files to your running HTTP server (inside the **container**) without stopping/restarting it. Use `curl` on your local VM to make sure that you have achieved this goal.

## 6 Building Your Own Images

### 6.1 From a Running Container

Previously, you changed the files inside your running container but if, for some reason this container stops running, for example because you stop it by mistake or because your VM crashes, all your changes will be lost. Fear not, though, it is possible to create an image from a running container so that your changes will not be lost (unless the hard drive of your VM crashes). 

Find a way to build a new image from your running container and start a new container from this new image. Use curl on your local VM to check that you have succeeded (do you see the three files `file1.html`, `file2.html` and `file3.html`?).

### 6.2 With a Dockerfile

So far, you have used a pre-packaged image that is available on the official Docker registry. You have built a new image by committing your modifications of the file system from the running container. As stated in the Docker documentation, it is better to use Dockerfiles to manage your images in a maintainable way. You can find the corresponding documentation at https://docs.docker.com/engine/reference/builder (as usual there is no need to read the whole page before doing something!). Your goal is to create a Docker image that serves a directory with `file1.html`, `file2.html` and `file3.html` that you have previously downloaded.

Inside the `mywebserver` directory, create a Docker file, named `Dockerfile` that:

- adds a `/data` directory to the container with the three files: `file1.html`, `file2.html` and `file3.html`.
- starts the python3 web server so that it serves the documents in `/data` rather than the root of the file system (Hint: it is enough to change the working directory to `/data` before starting the python interpreter). Please, use the *exec form* of the `CMD` instruction in your Docker file to start the python3 web server (`CMD ["executable","param1","param2","param3"]`)

Once your Docker file is ready, you may execute the following commands to 1) build your image 2) launch a container from your image.

```
> docker build -t ws:latest .
> docker run ws:latest
```

The `-t` option to the `docker build` command is used to name and tag your image. The `.` means that the docker file is in the current directory (the default name for a docker file is `Dockerfile`, therefore there is no need to specify its name explicitly). For more information, type `man docker-build` and `man docker-run` in a Terminal.

Like in the previous section, try to reach your HTTP server running inside the docker container by using the `curl` command.

## 7 Pushing Docker Images on a Private Registry

Up until now, your image is local to your VM and you can only use it locally. To make it usable from other machines (OpenStack servers for example), you need to push it to a registry. Then, from any docker host with access to that registry, you will be able to pull it and to run a container from the image.

Thanks to the **Docker Container Registry** integrated with GitLab, every project can have its own space to store its Docker images. You need to install a Certificate Authority (CA) root certificate for being authorized to use this registry.

Install the certificate by using the following commands:

```
> wget http://www.cloud.rennes.enst-bretagne.fr/files/docker-lab/root-ca.crt
> sudo cp root-ca.crt /usr/local/share/ca-certificates
> sudo update-ca-certificates
```

Make sure you have a **Packages > Container Registry** entry under your project’s sidebar.

### 7.1 Create a Personal Access Token

As your project is private, credentials have to be provided for authorization to use the registry associated to your project. You will use a personal access token to obtain the credentials.

Follow these instructions to obtain the credentials:

- Log in to GitLab.
- In the upper-right corner, click your avatar and select Settings.
- On the User Settings menu, select Access Tokens.
- Choose a name and optional expiry date for the token.
- Choose the following desired scope: `api`
- Click the Create personal access token button.
- Save the personal access token somewhere safe. Once you leave or refresh the page, you won’t be able to access it again.

### 7.2 Push an Image from your Local Machine

On your local VM, type the following command to authenticate to the GitLab Container Registry. Use your usual school username when prompted and then your personal access token as the password. (If you get an error message about the certificate authority not being recognized, try rebooting your VM.)

```
> docker login gitlab.imt-atlantique.fr
```

And that's it! You should now be able to push docker images into your registry.

Using the following commands, tag and push your image (replace `xy` and `somename` by appropriate values.

```
> docker tag [Image ID] gitlab.imt-atlantique.fr/devops-s23/devops-s23-xy/somename
> docker push gitlab.imt-atlantique.fr/devops-s23/devops-s23-xy/somename
```

## 8 Final Exercise

This last exercise is intended to draw your attention to some of the limitations of the container approach (as you have used it so far) and to help you discover ways around these limitations.

The objective of this exercice is to build and use a docker image integrating a Mongo server while respecting the following objectives:

- Build a new image (`mongo-perso`) which, by default, starts a Mongo server
- The first execution of a container from the `mongo-perso` image should lead to the initialization of some documents in a collection named `photographers` in a database named `artists`.
- If you kill and start a new container using the same image, you will find the documents that were inserted during the previous use of containers from the same image.
- The Mongo server, although running in a Docker container with its own IP address, must be reachable on port `27017` on `localhost`

The capture below shows a possible scenario of use of your image if you respect the instructions. A Mongo container is started (1) from the image that you have previously constructed. We check (2) the content of the `photographers` collection in the `artists` database (note that we use localhost for the connection to the database) to verify that the collection has been initialized correctly when the container is started. Then we add a photographer (3) and we check (4) that it has been added correctly. We stop (5) the container and destroy (6) it. We start (7) a new container and check (8) that the `photographers` collection still contains the same photographers.

```
(1)> docker run --name mymongo [other options] mongo-perso
(2)> mongo localhost/artists --eval "db.photographers.find()"
     MongoDB shell version v3.6.8
     connecting to: mongodb://localhost:27017/artists
     { "_id" : ObjectId("62011e459f6585c2d0661bb7"), "name" : "alice", "interests" : [ "portrait", "landscape" ] }
     { "_id" : ObjectId("62011e459f6585c2d0661bb8"), "name" : "bob", "interests" : [ "street", "sports" ] }
(3)> mongo localhost/artists --eval "db.photographers.insertOne({ name: 'doisneau', interests:['street'] })"
(4)> mongo localhost/artists --eval "db.photographers.find()"
     MongoDB shell version v3.6.8
     connecting to: mongodb://localhost:27017/artists
     { "_id" : ObjectId("62011e459f6585c2d0661bb7"), "name" : "alice", "interests" : [ "portrait", "landscape" ] }
     { "_id" : ObjectId("62011e459f6585c2d0661bb8"), "name" : "bob", "interests" : [ "street", "sports" ] }
     { "_id" : ObjectId("62011eaa6a86595a8435ebca"), "name" : "doisneau", "interests" : [ "street" ] }
(5)> docker stop mymongo
(6)> docker rm mymongo
(7)> docker run --name mymongo [other options] mongo-perso
(8)> mongo localhost/artists --eval "db.photographers.find()"
     MongoDB shell version v3.6.8
     connecting to: mongodb://localhost:27017/artists
     { "_id" : ObjectId("62011e459f6585c2d0661bb7"), "name" : "alice", "interests" : [ "portrait", "landscape" ] }
     { "_id" : ObjectId("62011e459f6585c2d0661bb8"), "name" : "bob", "interests" : [ "street", "sports" ] }
     { "_id" : ObjectId("62011eaa6a86595a8435ebca"), "name" : "doisneau", "interests" : [ "street" ] }
```

## 9 Docker versus containerd

Very soon, you will discover the use of **Kubernetes** to orchestrate containers on a network of hosts. You may be surprised to learn that Docker is not installed on the workers that will run the Docker containers.

It turns out that Docker is now just a high-level interface to other software layers that implement container abstraction (notably **containerd** and **runc**). It is essential to install Docker when you need to manipulate images, containers, data volumes, … but it is quite possible to do without Docker when using an orchestrator like Kubernetes which is smart enough to communicate directly with low-level software layers. There is one drawback, however, when it comes to building images, but this will be discussed later in the UE.

## 10 Key Takeaways

- One can use docker to:
  - Create a container image.
  - Start/stop/monitor containers.
- A container image is a file archive plus an "entry point" (i.e., the command to execute when the container starts).
- A Dockerfile is the "recipe" that Docker uses to build a container (with one file system layer for each instruction in the Dockerfile).
- By default, a Docker container, has its own IP address. Each container is connected to a virtual bridge on the host machine.
- One can push a Docker image to a (remote) registry so that the same image can be pulled by other hosts.

Author: Alberto Blanc, Jean-Pierre Le Narzul

Created: 2023-01-04 Wed 11:05

[Validate](https://validator.w3.org/check?uri=referer)