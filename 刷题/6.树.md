
## 如何写递归
这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1.  **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2.  **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3.  **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
好了，我们确认了递归的三要素，接下来就来练练手：


## 1.二叉树
### Intro
二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。


### 1.1.遍历
二叉树的深度优先遍历的非递归的通用做法是采用**栈**，广度优先遍历的非递归的通用做法是采用**队列**
#### 深度优先遍历
深度优先遍历对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。

不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。
通常深度优先搜索法不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。


##### 前序遍历（非递归
栈


##### 中序遍历（非递归
栈
保证：**在==左子树==访问之前，当前节点不能提前出栈**


##### 后序遍历（非递归
栈

用一个prev记录之前访问过的节点，用来确认右孩子有没有被访问过

保证：**在==左右孩子节点==访问结束之前，当前节点不能提前出栈**。

回溯算法就是一个N叉树的前序遍历加上后序遍历而已
[[9.基础算法#回溯算法]]

#### 广度优先遍历
保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。
广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些。

##### 层序遍历

```python
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return
        res=[]
        queue=[root]
        l=0
        while queue:
            l=len(queue)
            level=[] 
            # 作为while循环里的一个局部变量定义level
            # 这样就可以每循环一层都清空一遍level
            while l:
                node=queue.pop(0) 
                # pop() 函数用于移除列表list中的一个元素(默认最后一个元素)，并且返回该元素的值。
                # 想要作为queue使用，用pop(0)移除第一个元素
                level.append(node.val)
                if node.left:queue.append(node.left)
                if node.right:queue.append(node.right)
                l -= 1
            if level:
                res.append(level)
        return res
```
