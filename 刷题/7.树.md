
## 1.二叉树
### Intro
二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。


### 1.1.遍历
二叉树的深度优先遍历的非递归的通用做法是采用**栈**，广度优先遍历的非递归的通用做法是采用**队列**
#### 深度优先遍历
深度优先遍历对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。

不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。
通常深度优先搜索法不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。


##### 前序遍历（非递归
栈


##### 中序遍历（非递归
栈
保证：**在==左子树==访问之前，当前节点不能提前出栈**


##### 后序遍历（非递归
栈

用一个prev记录之前访问过的节点，用来确认右孩子有没有被访问过

保证：**在==左右孩子节点==访问结束之前，当前节点不能提前出栈**。

回溯算法就是一个N叉树的前序遍历加上后序遍历而已
[[9.基础算法#回溯算法]]

#### 广度优先遍历
保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。
广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些。

##### 层序遍历

