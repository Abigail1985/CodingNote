**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1.  确定dp数组（dp table）以及下标的含义
2.  确定递推公式
3.  dp数组如何初始化
4.  确定遍历顺序
5.  举例推导dp数组

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**

## 509.斐波那契数列
动规五部曲：

这里我们要用一个一维dp数组来保存递归的结果

1.  确定dp数组以及下标的含义

dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2.  确定递推公式

为什么这是一道非常简单的入门题目呢？

**因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

3.  dp数组如何初始化

**题目中把如何初始化也直接给我们了，如下：**

```
dp[0] = 0;
dp[1] = 1;
```

4.  确定遍历顺序

从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

5.  举例推导dp数组

按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

0 1 1 2 3 5 8 13 21 34 55

如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

以上我们用动规的方法分析完了，C++代码如下：

```
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

-   时间复杂度：O(n)
-   空间复杂度：O(n)

 ## 96.不同的二叉搜索树
思路：三种把新数字附加到dp[i-1]树的方案
	- 1.作为dp[i-1]这颗树的整个的头节点，一共有dp[i-1]种可能性
	- 2.作为dp[i-1]这颗树的整个的最右边的叶节点，一共有dp[i-1]种可能性
	- 3.插入dp[i-1]这颗树中间，这个情况最难
		- 例如：1，2，3，4，5，6，插入7
		- 如果插到1和2之间，左右分别为1和23456，可能的树的数量是dp[1]\*dp[5]
		- 如果插到2和3之间，左右分别为12和3456，可能的树的数量是dp[2]\*dp[4]
		- ....
		- 如果插到5和6之间，左右分别为12345和6，可能的树的数量是dp[5]\*dp[1]
		- 对上面所有可能性数量求和，附加到情况1和2的后面