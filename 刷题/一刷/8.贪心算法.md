
贪心算法一般分为如下四步：

-   将问题分解为若干个子问题
-   找出适合的贪心策略
-   求解每一个子问题的最优解
-   将局部最优解堆叠成全局最优解

这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。

做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。

## 406.根据身高重建队列
- 有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。
- `people=sorted(people,key=lambda x:(-x[0],x[1]))`lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序
- 按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列
- 没想到的：![][https://code-thinking-1253855093.file.myqcloud.com/pics/20201216201851982.png]
- 回归本题，整个插入过程如下：
	排序完的people： \[[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]
	插入的过程：
	-   插入[7,0]：\[[7,0]]
	-   插入[7,1]：\[[7,0],[7,1]]
	-   插入[6,1]：\[[7,0],[6,1],[7,1]]
	-   插入[5,0]：\[[5,0],[7,0],[6,1],[7,1]]
	-   插入[5,2]：\[[5,0],[7,0],[5,2],[6,1],[7,1]]
	-   插入[4,4]：\[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]