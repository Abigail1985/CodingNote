
```python
#
# @lc app=leetcode.cn id=76 lang=python
#
# [76] 最小覆盖子串
#

# @lc code=start
class Solution(object):
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        lo=hi=0
        l=list(s)
        # 如何处理need中重复的字符？
        need={}
        for i in list(t):
            if i in need:
                need[i]=need[i]+1
            need[i]=1
        seen={}
        count_hi=len(list(t))
        count_lo=0
        valid_hi=1
        valid_lo=0
        length=0
        left=right=0
        
        while hi<len(l):
            if valid_hi=1:
                while count_hi>0:
                    if l[hi] in need:
                        if l[hi] not in seen:
                            seen[l[hi]]=1
                            count_hi=count_hi-1
                        else:
                            if seen[l[hi]]<need[l[hi]]:
                                count_hi=count_hi-1
                            seen[l[hi]]=seen[l[hi]]+1 
                            #只要遇见都在seen里加1，但不一定每次都减valid
                valid_hi=0
                valid_lo=1
                
            #现在发现count_lo出while循环的判断条件不对
            if valid_lo=1:
                while count_lo<len(list(t)):
                    if l[lo] not in need:
                        lo=lo+1
                    else:
                        if seen[l[lo]]==need[l[lo]]:
                            count_lo=count_lo+1
                        else:
                            seen[l[lo]]=seen[l[lo]]-1
                            lo=lo+1
                valid_lo=0
                valid_hi=1
            if hi-lo+1<length:
                length=hi-lo
                left=lo
                right=hi
        return str(l[lo:hi])

            
            
# @lc code=end


```

