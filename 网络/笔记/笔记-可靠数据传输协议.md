
[TOC]



# RDT的基本结构：接口



![image-20211108110218884](https://i.loli.net/2021/11/08/evtMZHCRPz47xSh.png)

- udt_send()和rdt_rcv()都是双向的，保证控制消息的双向流动



接下来：

- 渐进地设计可靠数据传输协议的发送方和接收方

- 只考虑单向数据传输（但控制信息双向流动）

- 利用状态机(Finite State Machine, FSM)刻画传输协议

  ![image-20211108110705154](https://i.loli.net/2021/11/08/MsRnxC28wgzUo5D.png)

# RDT1.0：可靠信道

## 问题和解决

不需要进行控制信息的交换——>发送方和接收方的FSM独立

## 发送方

![image-20211108111215150](https://i.loli.net/2021/11/08/5lpDs6c9vuIreGj.png)

- packet = make_pkt(data)：
- udt_send(packet)：



## 接收方

![image-20211108111231963](https://i.loli.net/2021/11/08/Xt3e91Y5Mwo8GBv.png)

- extract (packet,data)
- deliver_data(data)

# RDT2.0：产生位错误的信道

## 问题和解决：停-等协议

![image-20211108111615006](https://i.loli.net/2021/11/08/ulrXhY45WSdynK1.png)

底层信道可能翻转分组中的位(bit)

- 利用校验和检测位错误

如何从错误中恢复？

- 确认机制(Acknowledgements, ACK)：接收方显式地告知发送方分组己正确接收
- NAK:接收方显式地告知发送方分组有错误
- 发送方收到NAK后，重传分组

基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest) 协议



Rdt 2.0中引入的新机制

- 差错检测
- 接收方反馈控制消息：ACK/NAK
- 重传



## 发送方

![image-20211108111917185](https://i.loli.net/2021/11/08/NrDxmK4fvphF2YU.png)

接到上层调用rdt_send()：

- 打包消息➕校验和

  *snkpkt = make_pkt(data, checksum)*

  *这里把checksum校验和加入了分组里，进行差错检测*

- 发送消息

进入**等待控制消息**状态



收到控制消息➕控制消息是NAK

- 重发消息

进入**等待控制消息**状态



收到控制消息➕控制消息是ACK

- 

进入**等待上层调用**状态



## 接收方

![image-20211108112745639](https://i.loli.net/2021/11/08/ZGCmpf3h9HUboB4.png)

收到分组➕检查出错误

- 返回NAK给发送方

进入等待下层调用状态（接收到消息，即被下层调用）



收到分组➕没检查出错误

- 解压
- 给上层应用传递数据

- 返回ACK给发送方

进入等待下层调用状态



# RDT2.1：应对ACK/NAK破坏

## RDT2.0的缺陷

**如果ACK/NAK消息发生错误/被破坏(corrupted)会怎么样？**：采用重传机制

几种备选方案：

- 为ACK/NAK增加校验和，检错并纠错
- 发送方收到被破坏ACK/NAK时不知道接收方发生了什么，添加额外的控制消息
- 如果ACK/NAK坏掉，发送方重传
  - 不能简单的重传：**产生重复分组**，接收方不知道收到的是新包还是发送方因为没听清重传的旧包

**重传导致了重复分组，如何解决重复分组问题？**：引入序列号

- 发送方给每个分组增加序列号(Sequence number)：用0标志旧包，用1标志新包
- 接收方丢弃重复分组

**序列号机制是怎样工作的？**

- 发送方如果接收到的回复包出问题了（corrupt（rcvpkt)），那么会重新发送一个序列号为0的包

  接收方接收到序列号为0的包，此时接收方已经返回了序列号为0的ACK包，此时在等待1

  而接收方收到0，就说明接收方是没有听清楚我的确认消息，重新发送了之前的包**，**

  由于stop-and-wait，接收方一定要接收到正确的包（序列号为1的包）之后才会发生状态转换，所以这个1序列包已经是我接收过的了，所以我发送一个ACK包回去，并且继续等待我的1号包

  

## 发送方

![image-20211108195236344](https://i.loli.net/2021/11/08/NY3DyOfdlQZuWgK.png)

发送序列号为０的分组，等待确认消息。

如果收到ACK，发送序列号为１的分组；

如果收到NAK或者错误的ACK/NAK，重传序列号为0的分组。

## 接收方

![image-20211108195420924](https://i.loli.net/2021/11/08/yMaBuJ3n45QbRH2.png)

如果收到正确序列号为0的分组发送ACK，错误就发送NAK，

如果期望收到序列号为0的分组却收到了序列号为1的分组，发送ACK。





## RDT2.0和RDT2.1

![image-20211108200407239](https://i.loli.net/2021/11/08/fUHjNbe5lawzpRd.png)

- 为什么rdt2.X只需要0和1两个序列号？

  <span style='color:red;background:背景颜色;font-size:文字大小;'>**序号的空间与窗口长度大小有关。停等模式中，序号只需要一个bit就可以了（0/1，序号空间为2），因为此时窗口长度为1。流水线模式下，最少得有窗口长度翻倍的序号空间。**</span>

# RDT2.2：无NAK消息协议



![image-20211115121806735](https://i.loli.net/2021/11/15/byhJd3YOL7m25VK.png)

# RDT3.0:丢包的信道

会丢失分组该怎么办？让发送方等待合理的时间

但是如何设定这个时间？定时器

但是如果分组或ack只是延迟而不是丢失导致重复发送了怎么办？序列号，接收方需要在ack中显示的告知所确认的分组

## 发送方

![image-20211115184010381](https://i.loli.net/2021/11/15/XituSVYZ2WrpjmG.png)

## 传输场景

### 一切正常

<img src="https://i.loli.net/2021/11/15/DAfj7lg2wMmcJp6.png" style="zoom:50%;" />

### 丢失分组

<img src="https://i.loli.net/2021/11/15/Vw4SldhRgaHD3Tq.png" alt="image-20211115184239507" style="zoom:50%;" />

### 丢失ACK

<img src="https://i.loli.net/2021/11/15/PNYx5pO62BImQyR.png" alt="image-20211115184418133" style="zoom:50%;" />

### 延迟超时

<img src="https://i.loli.net/2021/11/15/NrOjCVulUzXQ5My.png" alt="image-20211115184526655" style="zoom:50%;" />



## 性能分析



**Rdt 3.0能够正确工作，但性能很差**



### 示例

求1Gbps链路，15ms端到端传播延迟，1KB分组的发送方利用率：
$$
T_{\text {transmit }}=\frac{L \text { (packet length in bits) }}{R \text { (transmission rate, bps) }}=\frac{8 \mathrm{~kb} / \mathrm{pkt}}{10^{9} \mathrm{~b} / \mathrm{sec}}=8 \text { microsec }
$$

- 传输速率：$1*10^9$ b per second
- <span style='color:red;background:背景颜色;font-size:文字大小;'>不知道为什么L是8kb/pkt</span>

发送方利用率：发送方发送时间百分比
$$
U_{\text {sender }}=\frac{L / R}{R T T+L / R}=\frac{.008}{30.008}=0.00027
$$

- RTT是那个15ms端到端传播延迟

在1Gbps链路上每30毫秒才发送一个分组：33KB/sec
网络协议限制了物理资源的利用，要软硬件结合设计匹配



### 原因：停等操作

![image-20211115192731080](https://i.loli.net/2021/11/15/Rugpq7rMPkXlNdi.png)



# 提高RDT3.0效率的机制

### 流水线

![image-20211115193132020](https://i.loli.net/2021/11/15/gxTzkrBedQ9ZWDa.png)

允许发送方在收到ACK之前连续发送多个分组

- 更大的**序列号范围**
- 发送方和/或接收方需要**更大的存储空间以缓存分组**

![image-20211115193406360](https://i.loli.net/2021/11/15/9jkGQ3AIK4UxBHg.png)

### 为了实现流水线：滑动窗口协议

- 滑动窗口协议： Sliding-window protocol
- 窗口
  - 允许使用的序列号范围
  - 窗口尺寸为N：最多有N个等待确认的消息

- 滑动窗口
  - 随着协议的运行，窗口在序列号空间内向前滑动
- 滑动窗口协议：GBN, S



### 滑动窗口协议：GBN

全名：Go-Back-N，回退N步

![image-20211115210429451](https://i.loli.net/2021/11/15/T7agOjJrqRxdbY3.png)

#### 发送方描述

- 分组头部包含k-bit序列号
- 窗口尺寸为N，最多允许N个分组未确认

- ACK(n)：确认到序列号n(包含n)的分组均已被正确接收
- 可能收到重复ACK
  - 为空中的分组设置计时器(timer）
- 超时 Timeout(n)事件：重传序列号大于等于n，还未确认（收到ACK）的所有分组

#### 发送方状态机

![image-20211115205045465](https://i.loli.net/2021/11/15/JuCP1DEaAXlrFpI.png)

- base：黄色开头处序列号
- nextseqnum：蓝色开头处序列号

- ``base = gelacknum(rcypkt)+1``表示标志该序列号本身及之前的都被确认了，而base变化，就意味着窗口滑动了

#### 接收方状态机

![image-20211115210938232](https://i.loli.net/2021/11/15/dXVtzBjsbiTcNAZ.png)

- ACK机制：发送拥有最高序列号的、己被正确接收的分组的ACK
  - 可能产生重复ACK
  - 只需要记住唯一的expectedseqnum
- 乱序到达的分组：
  - 直接丢弃 ，接收方没有缓存
  - 重新确认序列号最大的、按序到达的分组



![texpad编译SJTUthesis注意把buidl script改成latexmk](https://i.loli.net/2021/11/15/CGukrOyA13sHD52.png)



#### 练习

> 数据链路层采用后退N帧（GBN)协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认则发送方需要重发的帧数是多少？分别是那几个帧？
>

根据GBN协议工作原理，GBN协议的确认是累积确认，所以此时发送端需要重发的帧数是4个，依次分别是4、5、6、7号帧。

**1号帧是怎么回事？**

事实上，发送方能收到2，3的确认信息，说明1已经成功送达了，否则接收方不会发送2，3的确认信息。

1号帧的ACK在返回给发送方时候丢失了



### 滑动窗口协议：SR

全名：Select-repeat

GBN乱序到达的分组会被拒绝，这导致效率很低

SR只重传没收到序列号的分组，这要求给每个分组都加上一个计时器，还让接收方也得有个窗口

![image-20211115222332441](https://i.loli.net/2021/11/15/XE2iODQdz4H31oc.png)

注意：发送方和接收方的窗口不是同步的，彼此不知道对方的状态

#### SR协议

![image-20211115232755842](https://i.loli.net/2021/11/15/We2hTZ7kjBOyxCF.png)

#### 缺陷

SR无法区分下面两种情况，这是因为序列号太少，解决掉办法就是保证序列号空间大小和窗口尺寸满足以下关系：
$$
N_{S}+N_{R}<=2^{k}
$$
![image-20211115233254347](https://i.loli.net/2021/11/15/gteaK3WOiETbusY.png)

